<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"> 
<html lang="de"> 
  <head> 
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/> 
    <title>Open Object Store</title> 
  	<link rel="stylesheet" type="text/css" href="style.css" />
  </head> 
  <body>
    <div id="wrapper">
      <div id="header">
        <ul>
          <li><a href="../index.html">Home</a></li>
          <li>Documention</li>
          <li><a href="../download.html">Download</a></li>
          <li><a href="../tutorial.html">Tutorial</a></li>
          <li><a href="../about.html">About</a></li>
        </ul>
        <div id="logo">
          <table cellspacing="0">
            <tr>
              <td class="oos">OOS</td>
              <td class="tagline">Store all your objects in one container.</td>
            </tr>
          </table>
        </div>
      </div>
      <div id="content">
        <div>
<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Overview</span></a></li>
      <li><a href="annotated.html"><span>Documentation</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Open Object Store Documentation</div>  </div>
</div>
<div class="contents">
<div class="textblock"> 
 <div class="width75 float_left">
 <h2><a class="anchor" id="intro_sec"></a>
Introduction</h2>
<p>The following documentation will give you an overview over the Open Object Store API. It will show you all main components of the software so that you can start building your own application with it.</p>
<p>OOS provides one container for all your objects. It let you access and filter your objects. Relation between object are tracked automatically. And with sessions and transactions you can persist your data.</p>
<p>All classes are inside the namespace oos. I tryed to give the library the look and feel of the STL so that it can interact with it easily.</p>
<p>As you will learn there is a base object (<a class="el" href="classoos_1_1object.html" title="The base class for all objects.">oos::object</a>) for all your objects. This object provide some methods and functionality importand to the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a>.</p>
<ul>
<li><b>unique id</b>: Each object gets a unique id independent of its type. That means there is a global id counter integrated in the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> to identify each object. This id is used as the primary key.</li>
</ul>
<ul>
<li><b>modify method</b>: When modifying an object attribute you have to use <a class="el" href="classoos_1_1object.html#a074a2d4129a34648d3cc124c05782370">oos::object::modify</a> so that the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> can keep track of the change made to an object.</li>
</ul>
<ul>
<li><b>provide serialize methods</b>: You have to overwrite the serialize methods <a class="el" href="classoos_1_1object.html#af5ec38b5637697f9eb6effe78dcc015c" title="Interface to read into object members.">oos::object::read_from</a> and <a class="el" href="classoos_1_1object.html#aa2943d66ea269357adc1f237eaea3ed0" title="Interface to write from object members.">oos::object::write_to</a> to give the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> the opportunity to know, read and write all attributes.</li>
</ul>
<p>Now lets start...</p>
<h2><a class="anchor" id="objects_sec"></a>
Objects</h2>
<p>As mentioned above there are a handful of rules you have to follow while intergrating your object classes into OOS.</p>
<h3><a class="anchor" id="step1"></a>
Step 1: Derive your class from oos::object.</h3>
<p>All your class or base classes must be derived from <a class="el" href="classoos_1_1object.html" title="The base class for all objects.">oos::object</a> and must have a default constructor.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Our first object based class</span>
 
 <span class="keyword">class </span>person : <span class="keyword">public</span> oos::object
 {
   std::string name_;

 <span class="keyword">public</span>:
   person();
   <span class="keyword">virtual</span> ~person();
 };
</pre></div><h3><a class="anchor" id="step2"></a>
Step 2: Provide propper acces methods.</h3>
<p>Write correct access (get/set) methods for all your member attributes. It is important when modifying an attribute to use the <a class="el" href="classoos_1_1object.html#a074a2d4129a34648d3cc124c05782370">oos::object::modify()</a> method. It tells the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> and the <a class="el" href="classoos_1_1object__observer.html" title="Base class for object observer classes.">oos::object_observer</a> objects that an object is modified.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> person::name(<span class="keyword">const</span> std::string &amp;n)
 {
   modify(name_, n);
 }

 std::string name()<span class="keyword"> const</span>
<span class="keyword"> </span>{
   <span class="keywordflow">return</span> name_;
 }
</pre></div><h3><a class="anchor" id="step3"></a>
Step 3: Make the class serializable.</h3>
<p>To make the class serializable you have to add and implement the methods <a class="el" href="classoos_1_1object.html#af5ec38b5637697f9eb6effe78dcc015c" title="Interface to read into object members.">oos::object::read_from()</a> and <a class="el" href="classoos_1_1object.html#aa2943d66ea269357adc1f237eaea3ed0" title="Interface to write from object members.">oos::object::write_to()</a>.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> person::read_from(<a class="code" href="classoos_1_1object__atomizer.html" title="Base class for all object atomizer.">oos::object_atomizer</a> *oa)
 {
   object::read_from(oa);
   oa-&gt;<a class="code" href="classoos_1_1object__atomizer.html#ac4782ffd9ae5d585728197cdcc2b53a4" title="Read a single character from the atomizer.">read</a>(<span class="stringliteral">&quot;name&quot;</span>, name_);
 }

 <span class="keywordtype">void</span> person::write_to(<a class="code" href="classoos_1_1object__atomizer.html" title="Base class for all object atomizer.">oos::object_atomizer</a> *oa)<span class="keyword"> const</span>
<span class="keyword"> </span>{
   object::write_to(oa);
   oa-&gt;<a class="code" href="classoos_1_1object__atomizer.html#aace8c211db0950cc8aef3aa9d9684a43" title="Write a single character to the atomizer.">write</a>(<span class="stringliteral">&quot;name&quot;</span>, name_);
 }
</pre></div><h2><a class="anchor" id="object_store_sec"></a>
The Object Store</h2>
<p>Now that you've written your object classes before you can insert them into the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> you have to make sure that the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> know these object types. Therefor you have to add the hierarchy of your objects.</p>
<h3><a class="anchor" id="prototypes"></a>
Setup the object hierarchy</h3>
<p>Assume we have a base class Vehicle and derived from this classes Truck, Car and Bike. Now lets make this hierarchy known to the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a>:</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> ostore;
 ostore.<a class="code" href="classoos_1_1object__store.html#adc959b6a1fdc043c3a22157e94a64c65">insert_prototype</a>&lt;Vehicle&gt;(<span class="stringliteral">&quot;vehicle&quot;</span>, <span class="keyword">true</span>);
 ostore.<a class="code" href="classoos_1_1object__store.html#adc959b6a1fdc043c3a22157e94a64c65">insert_prototype</a>&lt;Truck, Vehicle&gt;(<span class="stringliteral">&quot;truck&quot;</span>);
 ostore.<a class="code" href="classoos_1_1object__store.html#adc959b6a1fdc043c3a22157e94a64c65">insert_prototype</a>&lt;Car, Vehicle&gt;(<span class="stringliteral">&quot;car&quot;</span>);
 ostore.<a class="code" href="classoos_1_1object__store.html#adc959b6a1fdc043c3a22157e94a64c65">insert_prototype</a>&lt;Bike, Vehicle&gt;(<span class="stringliteral">&quot;bike&quot;</span>);
</pre></div><p>As you can see it is quite simple to add the hierarchy to the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a>. Via the template parameter you tell which type you want to add. With the first paramter you give your type a name. The second parameter is a flag telling the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> that this type is abstract and you can't add objects of this type to the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a>. Finally the last (third) parameter tells the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> about the objects parent type. When this name isn't given the parent class will be the <a class="el" href="classoos_1_1object.html" title="The base class for all objects.">oos::object</a> type.</p>
<h3><a class="anchor" id="add_objects"></a>
Add objects</h3>
<p>Now that we've setup up our hierarchy we can add new objects to the <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a>.</p>
<div class="fragment"><pre class="fragment"> ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> Truck(<span class="stringliteral">&quot;MAN&quot;</span>);
 ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> Car(<span class="stringliteral">&quot;VW Beetle&quot;</span>);
 ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> Bike(<span class="stringliteral">&quot;Honda&quot;</span>);
</pre></div><h3><a class="anchor" id="modify_objects"></a>
Modify objects</h3>
<p>Now that we have some objects inserted we may want to modify them. The important thing here is that you don't deal with raw pointer to your object when try to modify it. You always have a pointer object wrapped around the object (like shared_ptr). Here it is called <a class="el" href="classoos_1_1object__ptr.html" title="The object_ptr holds a pointer to an object.">oos::object_ptr</a>. So how do you get such a <a class="el" href="classoos_1_1object__ptr.html" title="The object_ptr holds a pointer to an object.">oos::object_ptr</a>? The <a class="el" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> for example returns an <a class="el" href="classoos_1_1object__ptr.html" title="The object_ptr holds a pointer to an object.">oos::object_ptr</a> object when you insert a new object. Once you received the <a class="el" href="classoos_1_1object__ptr.html" title="The object_ptr holds a pointer to an object.">oos::object_ptr</a> you can change your object by using it like usual pointer.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> <a class="code" href="classoos_1_1object__ptr.html" title="The object_ptr holds a pointer to an object.">oos::object_ptr&lt;Truck&gt;</a> truck_ptr;
 truck_ptr truck = ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> Truck(<span class="stringliteral">&quot;MAN&quot;</span>));
 
 truck-&gt;weight(2.5);
 truck-&gt;color(<span class="stringliteral">&quot;red&quot;</span>);
</pre></div><h3><a class="anchor" id="remove_objects"></a>
Remove objects</h3>
<p>Once we have an object_ptr object we can easily delete this object from the object_store by calling <a class="el" href="classoos_1_1object__store.html#a2f270d04113962cf27df38dc15a0779a">oos::object_store::remove()</a></p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> <a class="code" href="classoos_1_1object__ptr.html" title="The object_ptr holds a pointer to an object.">oos::object_ptr&lt;Truck&gt;</a> truck_ptr;
 truck_ptr truck = ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> Truck(<span class="stringliteral">&quot;MAN&quot;</span>));
 
 <span class="keywordflow">if</span> (ostore.<a class="code" href="classoos_1_1object__store.html#a2f270d04113962cf27df38dc15a0779a">remove</a>(truck)) {
   <span class="comment">// successfully removed object</span>
 } <span class="keywordflow">else</span> {
   <span class="comment">// object removal failed</span>
 }
</pre></div><p>When removing an object internally a check is done if the object (and subsequently all connected objects) can be removed. This test is done by checking the pointer and reference count of each concerning object. If the test succeeds the object is removed and true is returned. If the test fails false is returned.</p>
<h2><a class="anchor" id="object_relations_sec"></a>
Object Releations</h2>
<p>When it comes to object relations you can use one to one and one to many relations in a straight forward way.</p>
<h3><a class="anchor" id="one_to_one"></a>
One to one relations</h3>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>address
 {
 <span class="keyword">public</span>:
 <span class="keyword">private</span>:
   std::string street_;
   std::string city_;
 };
</pre></div><div class="fragment"><pre class="fragment"> <span class="keyword">class </span>person
 {
 <span class="keyword">public</span>:
   <span class="comment">//...</span>

 <span class="keyword">private</span>:
   <a class="code" href="classoos_1_1object__ptr.html" title="The object_ptr holds a pointer to an object.">oos::object_ptr&lt;address&gt;</a> address_;
 };
</pre></div><h3><a class="anchor" id="one_to_many"></a>
One to many relations</h3>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>person
 {
 <span class="keyword">public</span>:
   <span class="keyword">typedef</span> <a class="code" href="classoos_1_1object__ref.html" title="The object_ref holds a pointer to an object.">oos::object_ref&lt;person&gt;</a> person_ref;
   <span class="keyword">typedef</span> <a class="code" href="classoos_1_1object__list.html" title="An object list class.">oos::object_list&lt;person_ref&gt;</a> person_list_t;
   <span class="keyword">typedef</span> person_list_t::iterator iterator;
   <span class="keyword">typedef</span> person_list_t::const_iterator const_iterator;

   <span class="comment">// c&#39;tor for person</span>
   person(<span class="keyword">const</span> std::string &amp;name)
     : name_(name)
     , friends_(this)
   {}

   std::string name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> name_; }

   <span class="keywordtype">void</span> add_friend(<span class="keyword">const</span> person_ref &amp;p)
   {
     friends_.push_back(p);
   }

   iterator begin() { <span class="keywordflow">return</span> friends_.begin(); }
   iterator end() { <span class="keywordflow">return</span> friends_.end(); }

 <span class="keyword">private</span>:
   std::string name_;
   person_list_t friends_;
 };
</pre></div><p>Access the list </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">typedef</span> <a class="code" href="classoos_1_1object__ptr.html" title="The object_ptr holds a pointer to an object.">oos::object_ptr&lt;person&gt;</a> person_ptr;

 <span class="comment">// create a new person</span>
 person_ptr p = ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> person(<span class="stringliteral">&quot;joe&quot;</span>));

 <span class="comment">// add some friends</span>
 p-&gt;add_friend(ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> person(<span class="stringliteral">&quot;walter&quot;</span>)));
 p-&gt;add_friend(ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> person(<span class="stringliteral">&quot;helen&quot;</span>)));
 p-&gt;add_friend(ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> person(<span class="stringliteral">&quot;tim&quot;</span>)));

 <span class="comment">// access all friends</span>
 person::iterator i = p-&gt;begin();
 <span class="keywordflow">for</span> (i; i != p-&gt;end(); ++i) {
   std::cout &lt;&lt; i-&gt;value()-&gt;name() &lt;&lt; std::endl;
 }
</pre></div><h2><a class="anchor" id="object_view_sec"></a>
Open a view</h2>
<div class="fragment"><pre class="fragment"> <span class="comment">// add some friends</span>
 ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> person(<span class="stringliteral">&quot;joe&quot;</span>))
 ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> person(<span class="stringliteral">&quot;walter&quot;</span>));
 ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> person(<span class="stringliteral">&quot;helen&quot;</span>));
 ostore.<a class="code" href="classoos_1_1object__store.html#a77514ee78979a91d2745f01184371e11">insert</a>(<span class="keyword">new</span> person(<span class="stringliteral">&quot;tim&quot;</span>));

 <span class="keyword">typedef</span> <a class="code" href="classoos_1_1object__view.html" title="Create a view for a concrete object type.">oos::object_view&lt;person&gt;</a> person_view_t;
 
 person_view_t pview(ostore);

 person_view_t::iterator i = pview.begin();
 <span class="keywordflow">for</span> (i; i != pview.end(); ++i) {
   std::cout &lt;&lt; i-&gt;name() &lt;&lt; std::endl;
 }
</pre></div><div class="fragment"><pre class="fragment"> <span class="keyword">class </span>student : <span class="keyword">public</span> person { <span class="comment">//... };</span>
 <span class="keyword">class </span>employee : <span class="keyword">public</span> person { <span class="comment">//... };</span>

 <a class="code" href="classoos_1_1object__store.html" title="A class that stores all kind of objects.">oos::object_store</a> ostore;
 ostore.<a class="code" href="classoos_1_1object__store.html#adc959b6a1fdc043c3a22157e94a64c65">insert_prototype</a>&lt;person&gt;(<span class="stringliteral">&quot;person&quot;</span>);
 ostore.<a class="code" href="classoos_1_1object__store.html#adc959b6a1fdc043c3a22157e94a64c65">insert_prototype</a>&lt;student, person&gt;(<span class="stringliteral">&quot;student&quot;</span>);
 ostore.<a class="code" href="classoos_1_1object__store.html#adc959b6a1fdc043c3a22157e94a64c65">insert_prototype</a>&lt;employee, person&gt;(<span class="stringliteral">&quot;employee&quot;</span>);

 <span class="keyword">typedef</span> <a class="code" href="classoos_1_1object__view.html" title="Create a view for a concrete object type.">oos::object_view&lt;person&gt;</a> person_view_t;
 
 person_view_t pview(ostore);

 person_view_t::iterator i = pview.begin();
 <span class="keywordflow">for</span> (i; i != pview.end(); ++i) {
   std::cout &lt;&lt; i-&gt;name() &lt;&lt; std::endl;
 }
</pre></div><h2><a class="anchor" id="object_expression_sec"></a>
Object Expressions</h2>
<h2><a class="anchor" id="database_sec"></a>
Persist Objects</h2>
 
 </div>
 <div class="width25 float_right">
  <b>Table of content</b> <br/>
 <a class="el" href="index.html#intro_sec">Introduction</a> <br/>
 <a class="el" href="index.html#objects_sec">Objects</a> <br/>
 <a class="el" href="index.html#object_store_sec">The Object Store</a> <br/>
 <a class="el" href="index.html#object_relations_sec">Object Releations</a> <br/>
 <a class="el" href="index.html#object_view_sec">Open a view</a> <br/>
 <a class="el" href="index.html#object_expression_sec">Object Expressions</a> <br/>
 <a class="el" href="index.html#database_sec">Persist Objects</a> <br/>
  
 </div>
  </div></div>
    <div class="clear" id="footer">Infos.</div>
  </div>
</body>
</html>
