/**
 * @htmlonly
 * <div class="width75 float_left">
 * @endhtmlonly
 * @mainpage
 *
 * @section intro_sec Introduction
 *
 * The following documentation will give you an overview over
 * the Open Object Store API. It will show you all main components
 * of the software so that you can start building your own application
 * with it.
 *
 * OOS provides one container for all your objects. It let you access
 * and filter your objects. Relation between object are tracked automatically.
 * And with sessions and transactions you can persist your data.
 *
 * All classes are inside the namespace oos. I tryed to give the library the
 * look and feel of the STL so that it can interact with it easily.
 * 
 * As you will learn there is a base object (oos::object) for all your objects. This
 * object provide some methods and functionality importand to the oos::object_store.
 *
 * - <b>unique id</b>: Each object gets a unique id independent of its type. That means there
 * is a global id counter integrated in the oos::object_store to identify each object. This id
 * is used as the primary key.
 *
 * - <b>modify method</b>: When modifying an object attribute you have to use oos::object::modify
 * so that the oos::object_store can keep track of the change made to an object.
 *
 * - <b>provide serialize methods</b>: You have to overwrite the serialize methods oos::object::read_from
 * and oos::object::write_to to give the oos::object_store the opportunity to know, read
 * and write all attributes.
 *
 * Now lets start...
 *
 * @section objects_sec Objects
 *
 * As mentioned above there are a handful of rules you have to follow while
 * intergrating your object classes into OOS.
 *
 * @subsection step1 Step 1: Derive your class from oos::object.
 *
 * All your class or base classes must be derived from oos::object
 * and must have a default constructor.
 *
 * @code
 * class person : public oos::object
 * {
 *   std::string name_;
 *
 * public:
 *   person();
 *   virtual ~person();
 * };
 * @endcode
 *
 * @subsection step2 Step 2: Provide propper acces methods.
 *
 * Write correct access (get/set) methods for all your member attributes.
 * It is important when modifying an attribute to use the oos::object::modify()
 * method. It tells the oos::object_store and the oos::object_observer objects
 * that an object is modified.
 *
 * @code
 * void person::name(const std::string &n)
 * {
 *   modify(name_, n);
 * }
 *
 * std::string name() const
 * {
 *   return name_;
 * }
 * @endcode
 *
 * @subsection step3 Step 3: Make the class serializable.
 *
 * To make the class serializable you have to add and implement
 * the methods oos::object::read_from() and oos::object::write_to().
 *
 * @code
 * void person::read_from(oos::object_atomizer *oa)
 * {
 *   object::read_from(oa);
 *   oa->read("name", name_);
 * }
 *
 * void person::write_to(oos::object_atomizer *oa) const
 * {
 *   object::write_to(oa);
 *   oa->write("name", name_);
 * }
 * @endcode
 *
 * @section object_store_sec The Object Store
 *
 * Now that you've written your object classes before you
 * can insert them into the oos::object_store you have to make sure
 * that the oos::object_store know these object types. Therefor you
 * have to add the hierarchy of your objects.
 *
 * @subsection prototypes Setup the object hierarchy
 *
 * Assume we have a base class Vehicle and derived from this classes
 * Truck, Car and Bike. Now lets make this hierarchy known
 * to the oos::object_store:
 *
 * @code
 * oos::object_store ostore;
 * ostore.insert_prototype<Vehicle>("vehicle", true);
 * ostore.insert_prototype<Truck, Vehicle>("truck");
 * ostore.insert_prototype<Car, Vehicle>("car");
 * ostore.insert_prototype<Bike, Vehicle>("bike");
 * @endcode
 *
 * As you can see it is quite simple to add the hierarchy to
 * the oos::object_store.
 * Via the template parameter you tell which type you want to add.
 * With the first paramter you give your type a name. The second parameter
 * is a flag telling the oos::object_store that this type is abstract
 * and you can't add objects of this type to the oos::object_store.
 * Finally the last (third) parameter tells the oos::object_store about
 * the objects parent type. When this name isn't given the parent class
 * will be the oos::object type.
 *
 * @subsection add_objects Add objects
 *
 * Now that we've setup up our hierarchy we can add new objects to
 * the oos::object_store.
 *
 * @code
 * ostore.insert(new Truck("MAN");
 * ostore.insert(new Car("VW Beetle");
 * ostore.insert(new Bike("Honda");
 * @endcode
 * 
 * @subsection modify_objects Modify objects
 *
 * Now that we have some objects inserted we may want
 * to modify them. The important thing here is that you
 * don't deal with raw pointer to your object when try
 * to modify it. You always have a pointer object wrapped
 * around the object (like shared_ptr).
 * Here it is called oos::object_ptr. So how do you get
 * such a oos::object_ptr?
 * The oos::object_store for example returns an oos::object_ptr
 * object when you insert a new object. Once you received
 * the oos::object_ptr you can change your object by using it
 * like usual pointer.
 * 
 * @code
 * typedef oos::object_ptr<Truck> truck_ptr;
 * truck_ptr truck = ostore.insert(new Truck("MAN"));
 * 
 * truck->weight(2.5);
 * truck->color("red");
 * @endcode
 * 
 * @subsection remove_objects Remove objects
 * Once we have an object_ptr object we can easily delete this
 * object from the object_store by calling oos::object_store::remove()
 *
 * @code
 * typedef oos::object_ptr<Truck> truck_ptr;
 * truck_ptr truck = ostore.insert(new Truck("MAN"));
 * 
 * if (ostore.remove(truck)) {
 *   // successfully removed object
 * } else {
 *   // object removal failed
 * }
 * @endcode
 *
 * When removing an object internally a check is done if
 * the object (and subsequently all connected objects) can be
 * removed. This test is done by checking the pointer and reference
 * count of each concerning object. If the test succeeds the object
 * is removed and true is returned. If the test fails false is
 * returned.
 *
 * @section object_relations_sec Object Releations
 *
 * When it comes to object relations you can use one to one and
 * one to many relations in a straight forward way.
 *
 * @subsection one_to_one One to one relations
 *
 * In this example we have two object types an address class
 * and a person class.
 * 
 * @code
 * class address : public oos::object
 * {
 * public:
 *   //...
 * 
 * private:
 *   std::string street_;
 *   std::string city_;
 * };
 * @endcode
 *
 * Each person class should have an address, so we add an
 * oos::object_ptr of type address to the members. That's
 * it. Now we have a one to one relationship beetween two
 * classes.
 *
 * @code
 * class person : public oos::object
 * {
 * public:
 *   //...
 *
 * private:
 *   oos::object_ptr<address> address_;
 * };
 * @endcode
 *
 * With this kind of relationship we have a hard linked
 * relationship. Which means if we remove the person from
 * our store the address object is removed as well.
 * 
 * In case we want to keep the address object we can use
 * a oos::object_ref of type adress instead of object_ptr.
 * 
 * @code
 * class person : public oos::object
 * {
 * private:
 *   oos::object_ref<address> address_;
 * };
 * @endcode
 *
 * With object_ref we have a soft link to the address inside
 * our person class and it won't be removed on a person removal.
 * We must explicitly remove the address.
 *
 * @subsection one_to_many One to many relations
 *
 * When it comes to one to many releationships it is also
 * quiet easy. OOS comes with three types of container
 * classes which can be used to setup one to many relationships.
 * Because these classes are designed in the same way as
 * the STL classes we can use them in the same way plus the
 * benefit of the relationship.
 * 
 * Our handy person class needs a list of friends which are also
 * of type person. And because we want this list with soft linked
 * person we use object_ref as the type of the list.
 *
 * @code
 * class person
 * {
 * public:
 *   // the value type of the list
 *   typedef oos::object_ref<person> person_ref;
 *   // the list definition
 *   typedef oos::object_list<person_ref> person_list_t;
 *   // shortcuts to the iterators
 *   typedef person_list_t::iterator iterator;
 *   typedef person_list_t::const_iterator const_iterator;
 *
 *   // c'tor for person
 *   person(const std::string &name)
 *     : name_(name)
 *     // the list need the person to handle the relationship
 *     , friends_(this) 
 *   {}
 *
 *   std::string name() const { return name_; }
 *
 *   // add a friend to persons friend list
 *   void add_friend(const person_ref &p)
 *   {
 *     friends_.push_back(p);
 *   }
 *
 *   // STL like iterators
 *   iterator begin() { return friends_.begin(); }
 *   iterator end() { return friends_.end(); }
 *
 * private:
 *   std::string name_;
 *   person_list_t friends_;
 * };
 * @endcode
 *
 * Why declare a list if we don't use it? Next is an example howto
 * to use our persons friend list.
 *
 * We insert a new person into the object_store. Than we insert and
 * immediatily add some persons as friends to our first person.
 *
 * @code
 * typedef oos::object_ptr<person> person_ptr;
 *
 * // create a new person
 * person_ptr p = ostore.insert(new person("joe"));
 *
 * // add some friends
 * p->add_friend(ostore.insert(new person("walter")));
 * p->add_friend(ostore.insert(new person("helen")));
 * p->add_friend(ostore.insert(new person("tim")));
 * @endcode
 *
 * Now we can simply iterate over the list like we used to
 * do it with all STL containers. Period.
 *
 * @code
 * // access all friends
 * person::iterator i = p->begin();
 * for (i; i != p->end(); ++i) {
 *   std::cout << i->value()->name() << std::endl;
 * }
 * @endcode
 *
 * @section object_view_sec Open a view
 *
 * In most cases we want to iterate over all objects of a certain
 * type. How can we achieve this? We open a view for the type we want
 * to inspect.
 *
 * Again we use our little person class and insert some persons into
 * our store.
 * 
 * @code
 * // add some friends
 * ostore.insert(new person("joe"))
 * ostore.insert(new person("walter"));
 * ostore.insert(new person("helen"));
 * ostore.insert(new person("tim"));
 * @endcode
 *
 * Than we create a view with the oos::object_view class. This class
 * takes as the template parameter the desired class type. Then we can
 * use the view like a STL list containing oos::object_ptr of our
 * desired type.
 *
 * @code
 * // shortcut to the person view
 * typedef oos::object_view<person> person_view_t;
 * 
 * person_view_t pview(ostore);
 *
 * person_view_t::iterator i = pview.begin();
 * for (i; i != pview.end(); ++i) {
 *   std::cout << i->name() << std::endl;
 * }
 * @endcode
 *
 * But this class can to somethig more for us. If we have a hierarchy
 * of classes, we can create a view of the base type and easily iterate
 * overall sub-types.
 * 
 * Look at the next example. We have a hierachy with the person class
 * as base class and inherited from that we have classes student and
 * employee.
 * And again we create a view of type person to access all objects of
 * type person including sub-types student and employee.
 *
 * @code
 * class student : public person { //... };
 * class employee : public person { //... };
 *
 * oos::object_store ostore;
 * ostore.insert_prototype<person>("person");
 * ostore.insert_prototype<student, person>("student");
 * ostore.insert_prototype<employee, person>("employee");
 *
 * typedef oos::object_view<person> person_view_t;
 * 
 * person_view_t pview(ostore);
 *
 * person_view_t::iterator i = pview.begin();
 * for (i; i != pview.end(); ++i) {
 *   std::cout << i->name() << std::endl;
 * }
 * @endcode
 *
 * @section expression_sec Find and Filter Objects
 *
 * When working with an oos::object_view you may want to find
 * a certain object or you want to apply a function only for
 * some of the objects in the view.
 *
 * To achieve this we can use the oos::object_view::find_if method
 * or we can use the global ::for_each_if() function. But how can we
 * define or filter criterium?
 *
 * First add some elements (persons) to the store and create the view.
 * As you can see we've extended the person class with an age attribute.
 *
 * @code
 * // add some friends
 * ostore.insert(new person("joe", 45))
 * ostore.insert(new person("walter", 56));
 * ostore.insert(new person("helen", 37));
 * ostore.insert(new person("tim", 14));
 * ostore.insert(new person("linda", 25));
 * ostore.insert(new person("lea", 30));
 * ostore.insert(new person("georg", 42));
 *  
 * typedef oos::object_view<person> person_view_t;
 * typedef person_view_t::iterator iterator;
 * 
 * person_view_t pview(ostore);
 * @endcode
 *
 * If we want to find the person of age 25 we can achieve this by using
 * the oos::object_view::find_if method. But first we have to create a
 * variable holding the method of our object which should be used for
 * comparation. Here it is person::age().
 *
 * @code
 * // create the variable
 * oos::variable<int, person> x(&person::age);
 *
 * // find the person of age 25
 * iterator i = pview.find_if(x == 25);
 * @endcode
 *
 * The call returns the first occurence of the object matching
 * the expression or the end iterator.
 *
 * If you want to apply a function to all objects matching a
 * certain expression use oos::for_each_if() and use it in the
 * following described way.
 *
 * @code
 * // print all persons with age between 20 and 60 years
 * void find_between_40_and_60(const person_ptr &p)
 * {
 *   std::cout << p->name() << " is between 40 and 60.\n";
 * }
 *
 * // declare a variable/literal for the age
 * oos::variable<int, person> x(&person::age);
 *
 * // use the for_each_if function
 * for_each_if(pview.begin(), pview.end(),
 *             x > 20 && x < 60,
 *             find_between_40_and_60);
 * @endcode
 *
 * All persons whos age lays between 40 and 60 are printed.
 *
 * @section database_sec Persist Objects
 *
 * When it comes to persistence you have to deal with sessions
 * and transactions. You have two create a session for a specific
 * database and wrap a transaction around your insertions or
 * modifications.
 *
 * After created a session objects youo can either create the
 * database schema ...
 *
 * @code
 * // create and open a session
 * oos::session ses("sqlite://person.db");
 *
 * // create the database schema
 * ses.create();
 * @endcode
 *
 * ... or load the data from database.
 *
 * @code
 * // load the data from database
 * ses.load();
 * @endcode
 *
 * Once the schema is created or the data is loaded you can start
 * and insert, update or delete your data. Therefor create a transaction
 * object with the current session and start the transaction by calling
 * oos::transaction::begin(). After completing your modifications call
 * oos::transaction::commit() to commit all your modifications to the
 * database. If in error occurred while doing your modifications catch
 * the exception. In the catch block you can call oos::transaction::rollback()
 * to rollback all your modifications.
 *
 * @code
 * // create a transaction for session
 *
 * oos::transaction tr(ses);
 * try {
 *   // begin the transaction
 *   tr.begin();
 *
 *   // insert some objects
 *   ostore.insert(new person("joe", 45))
 *   ostore.insert(new person("walter", 56));
 *   ostore.insert(new person("helen", 37));
 *   ostore.insert(new person("tim", 14));
 *
 *   // commit the modifications
 *   tr.commit();
 * } catch (exception &ex) {
 *   // on error rollback transactions
 *   tr.rollback();
 * }
 * @endcode
 *
 * @htmlonly
 * </div>
 * <div class="width25 float_right">
 * @endhtmlonly
 * <b>Table of content</b> @n
 * <ul>
 *   <li>@ref intro_sec</li>
 *   <li>@ref objects_sec</li>
 *   <li>@ref object_store_sec</li>
 *   <li>@ref object_relations_sec</li>
 *   <li>@ref object_view_sec</li>
 *   <li>@ref expression_sec</li>
 *   <li>@ref database_sec</li>
 * </ul>
 * @htmlonly
 * </div>
 * @endhtmlonly
 */
