/**
 * @htmlonly
 * <!--div class="width_66" class="float_left"-->
 * @endhtmlonly
 * @mainpage
 *
 * @section intro_sec Introduction
 *
 * The following documentation will give you an overview over
 * the Open Object Store API. It will show you all main components
 * of the software so that you can start building your own application
 * with it.
 *
 * OOS provides one container for all your objects. It let you access
 * and filter your objects. Relation between object are tracked automatically.
 * And with sessions and transactions you can persist your data.
 *
 * All classes are inside the namespace oos. I tryed to give the library the
 * look and feel of the STL so that it can interact with it easily.
 * 
 * As you will learn there is a base object (oos::object) for all your objects. This
 * object provide some methods and functionality importand to the oos::object_store.
 *
 * - <b>unique id</b>: Each object gets a unique id independent of its type. That means there
 * is a global id counter integrated in the oos::object_store. This id is used as the
 * primary key.
 *
 * - <b>modify method</b>: When modifying an object attribute you have to use oos::object::modify
 * so that the oos::object_store can keep track of the change made to an object.
 *
 * - <b>provide serialize methods</b>: You have to overwrite the serialize methods oos::object::read_from
 * and oos::object::write_to to give the oos::object_store the opportunity to know, read
 * and write all attributes.
 *
 * Now lets start...
 *
 * @section create_objects_sec Creating objects
 *
 * As mentioned above there are a handful of rules you have to follow while
 * intergrating your object classes into OOS.
 *
 * @subsection step1 Step 1: Derive your class from oos::object.
 *
 * All your class or base classes must be derived from oos::object
 * and must have a default constructor.
 *
 * @code
 * // Our first object based class
 * 
 * class person : public oos::object
 * {
 *   std::string name_;
 *
 * public:
 *   person();
 *   virtual ~person();
 * };
 * @endcode
 *
 * @subsection step2 Step 2: Provide propper acces methods.
 *
 * Write correct access (get/set) methods for all your member attributes.
 * It is import when modifying an attribute to use the oos::object::modify()
 * method. It tells the oos::object_store and the oos::object_observer objects
 * that an object is modified.
 *
 * @code
 * void person::name(const std::string &n)
 * {
 *   modify(name_, n);
 * }
 *
 * std::string name() const
 * {
 *   return name_;
 * }
 * @endcode
 *
 * @subsection step3 Step 3: Make the class serializable.
 *
 * To make the class serializable you have to add and implement
 * the two methods oos::object::read_from() and oos::object::write_to().
 *
 * @code
 * void person::read_from(oos::object_atomizer *oa)
 * {
 *   object::read_from(oa);
 *   oa->read_string("name", name_);
 * }
 *
 * void person::write_to(oos::object_atomizer *oa) const
 * {
 *   object::write_to(oa);
 *   oa->write_string("name", name_);
 * }
 * @endcode
 *
 * @section object_store_sec The Object Store
 *
 * Now that you've written your object classes before you
 * can insert them into the oos::object_store you have to make sure
 * that the oos::object_store know these object types. Therefor you
 * have to add the hierarchy of your objects.
 *
 * @subsection prototypes Setup the object hierarchy
 *
 * Assume we have a base class Vehicle and derived from this classes
 * Truck, Car and Bike. Now lets make this hierarchy known
 * to the oos::object_store:
 *
 * @code
 * oos::object_store ostore;
 * ostore.insert_prototype<Vehicle>("vehicle", true);
 * ostore.insert_prototype<Truck>("truck", false, "vehicle");
 * ostore.insert_prototype<Car>("car", false, "vehicle");
 * ostore.insert_prototype<Bike>("bike", false, "vehicle");
 * @endcode
 *
 * As you can see it is quite simple to add the hierarchy to
 * the oos::object_store.
 * Via the template parameter you tell which type you want to add.
 * With the first paramter you give your type a name. The second parameter
 * is a flag telling the oos::object_store that this type is abstract
 * and you can't add objects of this type to the oos::object_store.
 * Finally the last (third) parameter tells the oos::object_store about
 * the objects parent type. When this name isn't given the parent class
 * will be the oos::object type.
 *
 * @subsection add_objects Add objects
 *
 * Now that we've setup up our hierarchy we can add new objects to
 * the oos::object_store.
 *
 * @code
 * ostore.insert(new Truck("MAN");
 * ostore.insert(new Car("VW Beetle");
 * ostore.insert(new Bike("Honda");
 * @endcode
 * 
 * @subsection modify_objects Modify objects
 *
 * @subsection remove_objects Remove objects
 *
 * @section object_view_sec Open a view
 *
 * @section object_relations_sec Object Releations
 *
 * @subsection one_to_one One to one relations
 *
 * @subsection one_to_many One to one relations
 *
 * @section object_expression_sec Object Expressions
 *
 * @section database_sec Persist Objects
 */
