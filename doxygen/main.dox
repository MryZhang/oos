/**
 * @htmlonly
 * <div class="width75 float_left">
 * @endhtmlonly
 * @mainpage
 *
 * @section intro_sec Introduction
 *
 * The following documentation will give you an overview over
 * the Open Object Store API. It will show you all main components
 * of the software so that you can start building your own application
 * with it.
 *
 * OOS provides one container for all your objects. It let you access
 * and filter your objects. Relation between object are tracked automatically.
 * And with sessions and transactions you can persist your data.
 *
 * All classes are inside the namespace oos. I tryed to give the library the
 * look and feel of the STL so that it can interact with it easily.
 * 
 * As you will learn there is a base object (oos::object) for all your objects. This
 * object provide some methods and functionality importand to the oos::object_store.
 *
 * - <b>unique id</b>: Each object gets a unique id independent of its type. That means there
 * is a global id counter integrated in the oos::object_store to identify each object. This id
 * is used as the primary key.
 *
 * - <b>modify method</b>: When modifying an object attribute you have to use oos::object::modify
 * so that the oos::object_store can keep track of the change made to an object.
 *
 * - <b>provide serialize methods</b>: You have to overwrite the serialize methods oos::object::read_from
 * and oos::object::write_to to give the oos::object_store the opportunity to know, read
 * and write all attributes.
 *
 * Now lets start...
 *
 * @section objects_sec Objects
 *
 * As mentioned above there are a handful of rules you have to follow while
 * intergrating your object classes into OOS.
 *
 * @subsection step1 Step 1: Derive your class from oos::object.
 *
 * All your class or base classes must be derived from oos::object
 * and must have a default constructor.
 *
 * @code
 * // Our first object based class
 * 
 * class person : public oos::object
 * {
 *   std::string name_;
 *
 * public:
 *   person();
 *   virtual ~person();
 * };
 * @endcode
 *
 * @subsection step2 Step 2: Provide propper acces methods.
 *
 * Write correct access (get/set) methods for all your member attributes.
 * It is important when modifying an attribute to use the oos::object::modify()
 * method. It tells the oos::object_store and the oos::object_observer objects
 * that an object is modified.
 *
 * @code
 * void person::name(const std::string &n)
 * {
 *   modify(name_, n);
 * }
 *
 * std::string name() const
 * {
 *   return name_;
 * }
 * @endcode
 *
 * @subsection step3 Step 3: Make the class serializable.
 *
 * To make the class serializable you have to add and implement
 * the methods oos::object::read_from() and oos::object::write_to().
 *
 * @code
 * void person::read_from(oos::object_atomizer *oa)
 * {
 *   object::read_from(oa);
 *   oa->read("name", name_);
 * }
 *
 * void person::write_to(oos::object_atomizer *oa) const
 * {
 *   object::write_to(oa);
 *   oa->write("name", name_);
 * }
 * @endcode
 *
 * @section object_store_sec The Object Store
 *
 * Now that you've written your object classes before you
 * can insert them into the oos::object_store you have to make sure
 * that the oos::object_store know these object types. Therefor you
 * have to add the hierarchy of your objects.
 *
 * @subsection prototypes Setup the object hierarchy
 *
 * Assume we have a base class Vehicle and derived from this classes
 * Truck, Car and Bike. Now lets make this hierarchy known
 * to the oos::object_store:
 *
 * @code
 * oos::object_store ostore;
 * ostore.insert_prototype<Vehicle>("vehicle", true);
 * ostore.insert_prototype<Truck, Vehicle>("truck");
 * ostore.insert_prototype<Car, Vehicle>("car");
 * ostore.insert_prototype<Bike, Vehicle>("bike");
 * @endcode
 *
 * As you can see it is quite simple to add the hierarchy to
 * the oos::object_store.
 * Via the template parameter you tell which type you want to add.
 * With the first paramter you give your type a name. The second parameter
 * is a flag telling the oos::object_store that this type is abstract
 * and you can't add objects of this type to the oos::object_store.
 * Finally the last (third) parameter tells the oos::object_store about
 * the objects parent type. When this name isn't given the parent class
 * will be the oos::object type.
 *
 * @subsection add_objects Add objects
 *
 * Now that we've setup up our hierarchy we can add new objects to
 * the oos::object_store.
 *
 * @code
 * ostore.insert(new Truck("MAN");
 * ostore.insert(new Car("VW Beetle");
 * ostore.insert(new Bike("Honda");
 * @endcode
 * 
 * @subsection modify_objects Modify objects
 *
 * Now that we have some objects inserted we may want
 * to modify them. The important thing here is that you
 * don't deal with raw pointer to your object when try
 * to modify it. You always have a pointer object wrapped
 * around the object (like shared_ptr).
 * Here it is called oos::object_ptr. So how do you get
 * such a oos::object_ptr?
 * The oos::object_store for example returns an oos::object_ptr
 * object when you insert a new object. Once you received
 * the oos::object_ptr you can change your object by using it
 * like usual pointer.
 * 
 * @code
 * typedef oos::object_ptr<Truck> truck_ptr;
 * truck_ptr truck = ostore.insert(new Truck("MAN"));
 * 
 * truck->weight(2.5);
 * truck->color("red");
 * @endcode
 * 
 * @subsection remove_objects Remove objects
 * Once we have an object_ptr object we can easily delete this
 * object from the object_store by calling oos::object_store::remove()
 *
 * @code
 * typedef oos::object_ptr<Truck> truck_ptr;
 * truck_ptr truck = ostore.insert(new Truck("MAN"));
 * 
 * if (ostore.remove(truck)) {
 *   // successfully removed object
 * } else {
 *   // object removal failed
 * }
 * @endcode
 *
 * When removing an object internally a check is done if
 * the object (and subsequently all connected objects) can be
 * removed. This test is done by checking the pointer and reference
 * count of each concerning object. If the test succeeds the object
 * is removed and true is returned. If the test fails false is
 * returned.
 *
 * @section object_relations_sec Object Releations
 *
 * When it comes to object relations you can use one to one and
 * one to many relations in a straight forward way.
 *
 * @subsection one_to_one One to one relations
 *
 * @code
 * class address
 * {
 * public:
 * private:
 *   std::string street_;
 *   std::string city_;
 * };
 * @endcode
 *
 * @code
 * class person
 * {
 * public:
 *   //...
 *
 * private:
 *   oos::object_ptr<address> address_;
 * };
 * @endcode
 *
 * @subsection one_to_many One to many relations
 *
 * @code
 * class person
 * {
 * public:
 *   typedef oos::object_ref<person> person_ref;
 *   typedef oos::object_list<person_ref> person_list_t;
 *   typedef person_list_t::iterator iterator;
 *   typedef person_list_t::const_iterator const_iterator;
 *
 *   // c'tor for person
 *   person(const std::string &name)
 *     : name_(name)
 *     , friends_(this)
 *   {}
 *
 *   std::string name() const { return name_; }
 *
 *   void add_friend(const person_ref &p)
 *   {
 *     friends_.push_back(p);
 *   }
 *
 *   iterator begin() { return friends_.begin(); }
 *   iterator end() { return friends_.end(); }
 *
 * private:
 *   std::string name_;
 *   person_list_t friends_;
 * };
 * @endcode
 *
 * Access the list
 * @code
 * typedef oos::object_ptr<person> person_ptr;
 *
 * // create a new person
 * person_ptr p = ostore.insert(new person("joe"));
 *
 * // add some friends
 * p->add_friend(ostore.insert(new person("walter")));
 * p->add_friend(ostore.insert(new person("helen")));
 * p->add_friend(ostore.insert(new person("tim")));
 *
 * // access all friends
 * person::iterator i = p->begin();
 * for (i; i != p->end(); ++i) {
 *   std::cout << i->value()->name() << std::endl;
 * }
 * @endcode
 *
 * @section object_view_sec Open a view
 *
 * @code
 * // add some friends
 * ostore.insert(new person("joe"))
 * ostore.insert(new person("walter"));
 * ostore.insert(new person("helen"));
 * ostore.insert(new person("tim"));
 *
 * typedef oos::object_view<person> person_view_t;
 * 
 * person_view_t pview(ostore);
 *
 * person_view_t::iterator i = pview.begin();
 * for (i; i != pview.end(); ++i) {
 *   std::cout << i->name() << std::endl;
 * }
 * @endcode
 *
 * @code
 * class student : public person { //... };
 * class employee : public person { //... };
 *
 * oos::object_store ostore;
 * ostore.insert_prototype<person>("person");
 * ostore.insert_prototype<student, person>("student");
 * ostore.insert_prototype<employee, person>("employee");
 *
 * typedef oos::object_view<person> person_view_t;
 * 
 * person_view_t pview(ostore);
 *
 * person_view_t::iterator i = pview.begin();
 * for (i; i != pview.end(); ++i) {
 *   std::cout << i->name() << std::endl;
 * }
 * @endcode
 *
 * @section object_expression_sec Object Expressions
 *
 * @section database_sec Persist Objects
 *
 * @htmlonly
 * </div>
 * <div class="width25 float_right">
 * @endhtmlonly
 * <b>Table of content</b> @n
 * <ul>
 *   <li>@ref intro_sec</li>
 *   <li>@ref objects_sec</li>
 *   <li>@ref object_store_sec</li>
 *   <li>@ref object_relations_sec</li>
 *   <li>@ref object_view_sec</li>
 *   <li>@ref object_expression_sec</li>
 *   <li>@ref database_sec</li>
 * </ul>
 * @htmlonly
 * </div>
 * @endhtmlonly
 */
