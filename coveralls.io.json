{
  "service_name": "travis-ci",
  "git": {
    "head": {
      "committer_email": "sascha.kuehl@gmx.net",
      "author_email": "sascha.kuehl@gmx.net",
      "author_name": "zussel",
      "message": "Update README.md",
      "committer_name": "zussel",
      "id": "48c04e86c8df052b9b92a90c35578f52368cfdb8"
    },
    "remotes": [],
    "branch": "master"
  },
  "source_files": [{
    "source": "#include \"calculator.hpp\"\n\ncalculator::calculator()\n  : store_(0)\n{}\n\ncalculator::~calculator() {}\n\nint calculator::add(int a, int b)\n{\n  return a + b;\n}\n\nint calculator::minus(int a, int b)\n{\n  return a - b;\n}\n\nint calculator::divide(int a, int divisor)\n{\n  return a / divisor;\n}\n\nint calculator::multiply(int a, int b)\n{\n  return a * b;\n}\n\nvoid calculator::store(int value)\n{\n  store_ = value;\n}\n  \nint calculator::restore()\n{\n  return store_;\n}\n",
    "name": "src/calculator.cpp",
    "coverage": ["None", "None", 1, 1, 1, "None", 1, "None", 1, "None", 1, "None", "None", 1, "None", 1, "None", "None", 1, "None", 1, "None", "None", 1, "None", 1, "None", "None", 1, "None", 1, 1, "None", 1, "None", 1, "None"]
  }, {
    "source": "#include \"calculator.hpp\"\n\n#include <iostream>\n\nint main (int, char *[])\n{\n\n  calculator calc;\n\n  int res = calc.add(1, 5);\n  \n  res = calc.minus(7, res);\n  \n  res = calc.divide(20, res);\n  \n  res = calc.multiply(5, res);\n\n  calc.store(res);\n  \n  res = calc.restore();\n\n  std::cout << "result: " << res << "\\n";\n\n  return 0;\n}\n",
    "name": "test_calc.cpp",
    "coverage": ["None", "None", "None", "None", 1, "None", "None", 1, "None", 1, "None", 1, "None", 1, "None", 1, "None", 1, "None", 1, "None", 1, "None", 1, 3]
  }, {
    "source": "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n\n#elif defined(__clang__)\n# define COMPILER_ID \"Clang\"\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"Watcom\"\n\n#elif defined(__SUNPRO_CC)\n# define COMPILER_ID \"SunPro\"\n\n#elif defined(__HP_aCC)\n# define COMPILER_ID \"HP\"\n\n#elif defined(__DECCXX)\n# define COMPILER_ID \"Compaq\"\n\n#elif defined(__IBMCPP__)\n# if defined(__COMPILER_VER__)\n#  define COMPILER_ID \"zOS\"\n# elif __IBMCPP__ >= 800\n#  define COMPILER_ID \"XL\"\n# else\n#  define COMPILER_ID \"VisualAge\"\n# endif\n\n#elif defined(__PGI)\n# define COMPILER_ID \"PGI\"\n\n#elif defined(__PATHSCALE__)\n# define COMPILER_ID \"PathScale\"\n\n#elif defined(_CRAYC)\n# define COMPILER_ID \"Cray\"\n\n#elif defined(__TI_COMPILER_VERSION__)\n# define COMPILER_ID \"TI_DSP\"\n\n#elif defined(__SCO_VERSION__)\n# define COMPILER_ID \"SCO\"\n\n#elif defined(__GNUC__)\n# define COMPILER_ID \"GNU\"\n\n#elif defined(_MSC_VER)\n# define COMPILER_ID \"MSVC\"\n\n#elif defined(__ADSPBLACKFIN__) || defined(__ADSPTS__) || defined(__ADSP21000__)\n/* Analog Devices C++ compiler for Blackfin, TigerSHARC and\n   SHARC (21000) DSPs */\n# define COMPILER_ID \"ADSP\"\n\n#elif defined(_SGI_COMPILER_VERSION) || defined(_COMPILER_VERSION)\n# define COMPILER_ID \"MIPSpro\"\n\n/* This compiler is either not known or is too old to define an\n   identification macro.  Try to identify the platform and guess that\n   it is the native compiler.  */\n#elif defined(__sgi)\n# define COMPILER_ID \"MIPSpro\"\n\n#elif defined(__hpux) || defined(__hpua)\n# define COMPILER_ID \"HP\"\n\n#else /* unknown compiler */\n# define COMPILER_ID \"\"\n\n#endif\n\n/* Construct the string literal in pieces to prevent the source from\n   getting matched.  Store it in a pointer rather than an array\n   because some compilers will just produce instructions to fill the\n   array rather than assigning a pointer to a static array.  */\nchar const* info_compiler = \"INFO\" \":\" \"compiler[\" COMPILER_ID \"]\";\n\n/* Identify known platforms by name.  */\n#if defined(__linux) || defined(__linux__) || defined(linux)\n# define PLATFORM_ID \"Linux\"\n\n#elif defined(__CYGWIN__)\n# define PLATFORM_ID \"Cygwin\"\n\n#elif defined(__MINGW32__)\n# define PLATFORM_ID \"MinGW\"\n\n#elif defined(__APPLE__)\n# define PLATFORM_ID \"Darwin\"\n\n#elif defined(_WIN32) || defined(__WIN32__) || defined(WIN32)\n# define PLATFORM_ID \"Windows\"\n\n#elif defined(__FreeBSD__) || defined(__FreeBSD)\n# define PLATFORM_ID \"FreeBSD\"\n\n#elif defined(__NetBSD__) || defined(__NetBSD)\n# define PLATFORM_ID \"NetBSD\"\n\n#elif defined(__OpenBSD__) || defined(__OPENBSD)\n# define PLATFORM_ID \"OpenBSD\"\n\n#elif defined(__sun) || defined(sun)\n# define PLATFORM_ID \"SunOS\"\n\n#elif defined(_AIX) || defined(__AIX) || defined(__AIX__) || defined(__aix) || defined(__aix__)\n# define PLATFORM_ID \"AIX\"\n\n#elif defined(__sgi) || defined(__sgi__) || defined(_SGI)\n# define PLATFORM_ID \"IRIX\"\n\n#elif defined(__hpux) || defined(__hpux__)\n# define PLATFORM_ID \"HP-UX\"\n\n#elif defined(__HAIKU) || defined(__HAIKU__) || defined(_HAIKU)\n# define PLATFORM_ID \"Haiku\"\n/* Haiku also defines __BEOS__ so we must \n   put it prior to the check for __BEOS__\n*/\n\n#elif defined(__BeOS) || defined(__BEOS__) || defined(_BEOS)\n# define PLATFORM_ID \"BeOS\"\n\n#elif defined(__QNX__) || defined(__QNXNTO__)\n# define PLATFORM_ID \"QNX\"\n\n#elif defined(__tru64) || defined(_tru64) || defined(__TRU64__)\n# define PLATFORM_ID \"Tru64\"\n\n#elif defined(__riscos) || defined(__riscos__)\n# define PLATFORM_ID \"RISCos\"\n\n#elif defined(__sinix) || defined(__sinix__) || defined(__SINIX__)\n# define PLATFORM_ID \"SINIX\"\n\n#elif defined(__UNIX_SV__)\n# define PLATFORM_ID \"UNIX_SV\"\n\n#elif defined(__bsdos__)\n# define PLATFORM_ID \"BSDOS\"\n\n#elif defined(_MPRAS) || defined(MPRAS)\n# define PLATFORM_ID \"MP-RAS\"\n\n#elif defined(__osf) || defined(__osf__)\n# define PLATFORM_ID \"OSF1\"\n\n#elif defined(_SCO_SV) || defined(SCO_SV) || defined(sco_sv)\n# define PLATFORM_ID \"SCO_SV\"\n\n#elif defined(__ultrix) || defined(__ultrix__) || defined(_ULTRIX)\n# define PLATFORM_ID \"ULTRIX\"\n\n#elif defined(__XENIX__) || defined(_XENIX) || defined(XENIX)\n# define PLATFORM_ID \"Xenix\"\n\n#else /* unknown platform */\n# define PLATFORM_ID \"\"\n\n#endif\n\n/* For windows compilers MSVC and Intel we can determine\n   the architecture of the compiler being used.  This is because\n   the compilers do not have flags that can change the architecture,\n   but rather depend on which compiler is being used\n*/\n#if defined(_WIN32) && defined(_MSC_VER)\n# if defined(_M_IA64)\n#  define ARCHITECTURE_ID \"IA64\"\n\n# elif defined(_M_X64) || defined(_M_AMD64)\n#  define ARCHITECTURE_ID \"x64\" \n\n# elif defined(_M_IX86)\n#  define ARCHITECTURE_ID \"X86\"\n\n# else /* unknown architecture */\n#  define ARCHITECTURE_ID \"\"\n# endif\n\n#else\n#  define ARCHITECTURE_ID \"\"\n#endif\n\n/* Construct the string literal in pieces to prevent the source from\n   getting matched.  Store it in a pointer rather than an array\n   because some compilers will just produce instructions to fill the\n   array rather than assigning a pointer to a static array.  */\nchar const* info_platform = \"INFO\" \":\" \"platform[\" PLATFORM_ID \"]\";\nchar const* info_arch = \"INFO\" \":\" \"arch[\" ARCHITECTURE_ID \"]\";\n\n\n\n/*--------------------------------------------------------------------------*/\n\nint main(int argc, char* argv[])\n{\n  int require = 0;\n  require += info_compiler[argc];\n  require += info_platform[argc];\n  (void)argv;\n  return require;\n}\n",
    "name": "CMakeFiles/CompilerIdCXX/CMakeCXXCompilerId.cpp",
    "coverage": ["None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None", "None"]
  }],
  "service_job_id": "17268465"
}
